<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herp Derp</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@7.0.0-beta.3/babel.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <section id="app">
    </section>

    <!-- <script>
        // to simulate async data fetching
        window.API = {
            fetchFrahnds(){
                return new Promise((res, rej) => {
                    const frahnds = [// frahnds data dumped here
                        {
                            name: 'Jake',
                            active: true,
                        }, 
                        {
                            name: 'Amy',
                            active: true,
                        }, 
                        {
                            name: 'Raymond',
                            active: true,
                        }, 
                        {
                            name: 'Charles',
                            active: true,
                        },
                        {
                            name: 'Rosa',
                            active: true,
                        }, 
                        {
                            name: 'Terry',
                            active: true,
                        }
                    ]
                    setTimeout(()=> res(frahnds), 2000) //resolve with the frahnds after 2s. faking the async nature of an ajax req
                })
            }
        }
    </script> -->


    <script type="text/babel">
        // tmg creates 2 separate components rather than templates within same FrahndsList component
        // filtered inside the App return rather than in the component
        function ActiveFriends(props){
            return (
                <section>
                    <h2>Active Friends</h2>
                    <ul>
                        {props.list
                            .map(frahnd => (
                                <li key={frahnd.name}> {/*React is zero amounts happy with this*/}
                                    <span>{frahnd.name}</span>
                                    <button onClick = { ()=> {props.onRemoveFriend(frahnd.name)} }>Bye {frahnd.name}!</button>
                                    <button onClick = { ()=> {props.onToggleFriend(frahnd.name)} }>Deactivate</button>
                            </li>
                        ))}
                    </ul>
                </section>
            )
        }
        function InactiveFriends(props){
            return (
                <section>
                    <h2>Inactive Friends</h2>
                    <ul>
                        {props.list
                            .map(frahnd => (
                            <li key={frahnd.name}> {/*React is zero amounts happy with this*/}
                                <span>{frahnd.name}</span>
                                <button onClick = { ()=> {props.onRemoveFriend(frahnd.name)} }>Bye {frahnd.name}!</button>
                                <button onClick = { ()=> {props.onToggleFriend(frahnd.name)} }>Activate</button>
                            </li>
                        ))}
                    </ul>
                </section>
            )
        }

        function App(){
            const { useState, useEffect } = React; //destructure from React; also add useEffect 
            const [frahndqueue, setFrahndqueue] = useState([]); //notice: what was once in 'frahnds' has been ported to a simulated API, thus useState initial value is empty array
            
            const [newFrahnd, setNewFrahnd] = useState('')

            function fetchPokemon(){
                let frahnds; /*one must fetch to fill this*/
                fetch(`https://pokeapi.co/api/v2/pokemon/?limit=6&offset=55`)
                    .then(res => res.json())
                    .then(data => {
                        console.log(data)
                        const frahnds = data.results.map(pokemon => ({ name: pokemon.name[0].toUpperCase()+pokemon.name.slice(1), active: true }))
                        setFrahndqueue(frahnds)
                    })
                    .catch(err => console.log(err))
            }

            useEffect(()=> { //takes a function as an arg
                fetchPokemon();
                // beware the infinite loop
            }, []) //but is this empty dep array true?

            function handleChange(e){
                setNewFrahnd(e.target.value)
            }
            function handleAddFriend(name){
                if (name !== '' && frahndqueue.filter(frahnd => frahnd.name === name).length === 0){ //i.e., the friend isn't there already and the thing isn't ''
                    const updatedFrahndQueue = frahndqueue.concat({name, active: true}) 
                    setFrahndqueue(updatedFrahndQueue) //now you make frahndqueue equal its updated self with the new frahnd
                    setNewFrahnd('') //clearing it after submission is best practice I think
                }
            }
            function toggleFriend(name){
                const frahndToEdit = frahndqueue.find(frahnd => frahnd.name === name)
                const updatedFrahndQueue = frahndqueue.filter(frahnd => frahnd.name !== name) 
                    .concat({ //then add a modified vers of the friend you removed
                        name,
                        active: !frahndToEdit.active //toggle to opposite of what it was
                    })
                setFrahndqueue(updatedFrahndQueue);
            }
            function clearAll(){
                setFrahndqueue([])
            }
            function handleRemoveFriend(name){
                const updatedFrahnds = frahndqueue.filter(friend => friend.name!==name)
                setFrahndqueue(updatedFrahnds)
            }
            return (
                <section id="container"> 
                    <h1>An odd tracker</h1>
                    <input 
                        type='text'
                        placeholder='Type new friend name'
                        value= {newFrahnd}
                        onChange={handleChange}  //need to capture the value of what's entered
                    />
                    <button
                        onClick = { ()=> { handleAddFriend(newFrahnd) }}
                    >
                        Submit
                    </button>
                    <button
                        onClick = {clearAll}
                    >Clear all
                    </button>
                    <ActiveFriends 
                        list= {frahndqueue.filter(frahnd => frahnd.active === true)} 
                    //  isActive= {false}
                        onAddFriend = { handleAddFriend }
                        onRemoveFriend = { handleRemoveFriend }
                        onToggleFriend = { toggleFriend }
                    />
                    <InactiveFriends
                        list= {frahndqueue.filter(frahnd => frahnd.active === false)}
                        onAddFriend = { handleAddFriend }
                        onRemoveFriend = { handleRemoveFriend }
                        onToggleFriend = { toggleFriend }
                    />
                        
                </section>
            )
        }
        const root = ReactDOM.createRoot(
            document.querySelector('#app')
        )
        root.render(<App />)
    </script>
</body>
</html>